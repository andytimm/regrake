# Run R solver on test cases generated by Python
#
# This script loads the test cases from test_cases/ and runs
# the regrake ADMM solver on them, saving results for comparison.

library(Matrix)

# Load regrake package (from parent directory)
devtools::load_all("..")

# Helper to load a test case
load_test_case <- function(case_name) {
  case_dir <- file.path("test_cases", case_name)

  if (!dir.exists(case_dir)) {
    stop("Test case directory not found: ", case_dir)
  }

  # Load design matrix
  F <- as.matrix(read.csv(file.path(case_dir, "F.csv"), header = FALSE))

  # Load losses specification
  losses_json <- jsonlite::fromJSON(file.path(case_dir, "losses.json"))

  # Load regularizer specification
  reg_json <- jsonlite::fromJSON(file.path(case_dir, "regularizer.json"))

  # Load lambda
  lam <- as.numeric(readLines(file.path(case_dir, "lambda.txt")))

  list(
    name = case_name,
    F = F,
    losses_spec = losses_json,
    regularizer_spec = reg_json,
    lam = lam
  )
}

# Convert losses spec to R loss objects
make_losses <- function(losses_spec) {
  # Handle case where jsonlite simplifies single-row arrays to data frames
  if (is.data.frame(losses_spec)) {
    # Convert data frame rows to list, preserving all fields
    losses_list <- lapply(seq_len(nrow(losses_spec)), function(i) {
      row <- list(type = losses_spec$type[i], target = losses_spec$target[[i]])
      if ("lower" %in% names(losses_spec)) row$lower <- losses_spec$lower[[i]]
      if ("upper" %in% names(losses_spec)) row$upper <- losses_spec$upper[[i]]
      if ("scale" %in% names(losses_spec)) row$scale <- losses_spec$scale[[i]]
      row
    })
  } else {
    losses_list <- losses_spec
  }

  lapply(losses_list, function(spec) {
    target <- spec$target
    switch(spec$type,
      "equality" = list(
        fn = equality_loss,
        target = target,
        prox = prox_equality,
        evaluate = function(x) sum(equality_loss(x, target))
      ),
      "least_squares" = list(
        fn = least_squares_loss,
        target = target,
        prox = prox_least_squares
      ),
      "inequality" = list(
        fn = inequality_loss,
        target = target,
        prox = prox_inequality,
        lower = spec$lower,
        upper = spec$upper
      ),
      "kl" = list(
        fn = function(x, t) kl_loss(x, t),
        target = target,
        prox = function(x, t, rho) prox_kl(x, t, rho, scale = if (!is.null(spec$scale)) spec$scale else 1),
        evaluate = function(x) sum(kl_loss(x, target))
      ),
      stop("Unknown loss type: ", spec$type)
    )
  })
}

# Convert regularizer spec to R regularizer object
make_regularizer <- function(reg_spec) {
  switch(reg_spec$type,
    "entropy" = list(
      fn = function(w, lambda) entropy_regularizer(w, lambda, reg_spec$limit),
      prox = function(w, lambda) prox_kl_reg(w, lambda, prior = NULL, limit = reg_spec$limit)
    ),
    "zero" = list(
      fn = zero_regularizer,
      prox = prox_equality_reg
    ),
    "kl" = {
      prior <- reg_spec$prior
      list(
        fn = function(w, lambda) kl_regularizer(w, lambda, prior, limit = NULL),
        prox = function(w, lambda) prox_kl_reg(w, lambda, prior = prior, limit = NULL)
      )
    },
    "boolean" = {
      k <- reg_spec$k
      structure(
        list(
          fn = function(w, lambda) w,
          prox = function(w, lambda) prox_boolean_reg(w, lambda, k)
        ),
        class = "BooleanRegularizer"
      )
    },
    stop("Unknown regularizer type: ", reg_spec$type)
  )
}

# Run solver on a test case
run_test_case <- function(case) {
  cat("Running:", case$name, "\n")

  # Convert to sparse matrix
  F <- Matrix::Matrix(case$F, sparse = TRUE)

  # Build losses
  losses <- make_losses(case$losses_spec)

  # Build regularizer
  reg <- make_regularizer(case$regularizer_spec)

  # Run ADMM
  result <- tryCatch({
    sol <- admm(
      F = F,
      losses = losses,
      reg = reg,
      lam = case$lam,
      control = list(
        maxiter = 5000,
        eps_abs = 1e-6,
        eps_rel = 1e-6,
        rho = 50
      ),
      verbose = FALSE
    )

    # Compute achieved values
    achieved <- as.numeric(F %*% sol$w_best)

    list(
      weights = sol$w_best,
      achieved = achieved,
      success = TRUE
    )
  }, error = function(e) {
    cat("  ERROR:", conditionMessage(e), "\n")
    list(success = FALSE, error = conditionMessage(e))
  })

  result
}

# Save R results
save_results <- function(case_name, result) {
  case_dir <- file.path("test_cases", case_name)

  if (result$success) {
    write.csv(result$weights, file.path(case_dir, "weights_r.csv"),
              row.names = FALSE)
    write.csv(result$achieved, file.path(case_dir, "achieved_r.csv"),
              row.names = FALSE)
    cat("  Saved results\n")
  }
}

# Main
main <- function() {
  # Find all test cases
  test_dirs <- list.dirs("test_cases", recursive = FALSE, full.names = FALSE)

  if (length(test_dirs) == 0) {
    stop("No test cases found. Run generate_test_cases.py first.")
  }

  cat("Found", length(test_dirs), "test cases\n\n")

  results <- list()
  for (case_name in sort(test_dirs)) {
    case <- load_test_case(case_name)
    result <- run_test_case(case)
    save_results(case_name, result)
    results[[case_name]] <- result
    cat("\n")
  }

  invisible(results)
}

# Run if executed directly
if (!interactive()) {
  main()
}
